next we're going to discuss the Merkle's puzzle so here we're going to discuss the Merkel's Pato Merkel's Pato has a very interesting history this is somehow kind of like an asymmetric encryption algorithm this is this happened a long time ago before the appearance of asymmetric encryption actually Merkel was taking a security class just like you guys is doing now Merkel was taking a security class and they that the instructor requires everybody to design a security protocol and actually Merkel designed this Magneto at that time the instructor is not convinced by the value of this protocol and I think Merkel will save a prepared a score on the project but it's a very interesting design and the basic idea is that we try to make the life of an eighth dropper very very difficult we want to cause a huge amount of overhead and that if dropper and attacker side and this is this is what Merkel's puddle trying to do ok so let's say we have two persons pallets in the bottom outlets in the Bob try to establish a key so let's say they try to establish a 128-bit key unfortunately they don't have a secure communication channel they don't have a trusted third party to transfer the key they cannot use USPS to mail the key so they have to figure out a way and that the approach here the approach here is to trade communication overhead for computation overhead is to trade communication overhead for computation overhead what does that's me so Alice will generate many 128-bit key we call them k1 k2 KN and we will generate many 64-bit key which we call them as one it's secret one secret to and the secret N and also we generate a lot of sequence number will generate a lot of sequence number let's call them t1 t2 2 TM ok so far so good you are generating a whole bunch of 128-bit key you're generating the same number of 64-bit key and you are generating the same number of sequence number okay so this is our this will be the message that Alice will generate Alice will select a symmetric encryption algorithm a symmetric encryption algorithm and used the 64-bit key to encrypt the sequence number with the corresponding key and then you to use the second secret key to encrypt the second sequence number the second key and so on and so forth of course since you generate n typos you needed to use the secret key s n to include the sequence number TN and the 128-bit key KN and the hash of the can so how many messages do you have you have a message all together you have one message all together so let's call this M one M two M N and then Alice will dump m1 m2 MN 2 Bob here is where we treated the communication overhead for computation overhead why because now we just want one key but we are sending a whole lot of message to the other side okay also we only want one key we're sending a lot of message to the other side and what will happen at the Bob side the Bob will randomly pick let's say a message am I okay so what is mi mi is something encrypted by a 64-bit key then Bob brute force to attack am i well does I mean so Bob try every possible key Bob will try every possible 64-bit key and the Bob will be able to open the message once Bob opened the message Bob will see TI ki hash of the ki and the Bob hashed this part to compare to this part to verify that he really opened this message once Bob opened this message Bob will reply said hey Alice I choose TI okay remember the TI si and a cow all generated by Alice so when Alice see the message that ababa truth TI he will she will immediately know which corresponding secret key Bob actually choose to use that is the K actor now both sides will know ki know yeah okay so now let's see what the bad guy can do it's a very interesting that's why we say it's a Merkel's puzzle it's a puzzle so let's see now we have a bad guy the bad guy will also resume m1 m2 - mm-hmm the bad guy and the later it will see oh the sequence number is T I remember TI is just a sequence number it look like a random number you cannot by looking at this random number TI to figure out which message it is okay so it could be the message one method or two methods 3 method for all the way to your message and the bad guy will not know so the bad guy see Oh Bob - Zi what am I going to do I'm going to do brute-force attack as well the first thing is I'm going to get m1 and crack it can the bad guy crack it of course if Bob can crack a 64-bit key the bad guy can crack a 64-bit key as well okay so he tried all possible 64 bits key which means the computation overhead is 2 to the power of 64 and then what does he get he got the t1 and the Kaiba fantastic is this useful unfortunately no why the bad guy compared T 1 to the TI that Bob choose they're different hmm okay so k1 is useless Bob does now choose k1 so what am I going to do I'm gonna try em - well actually it doesn't matter you don't have to choose em - the bad guy can choose m5 and 100 or m1 500 you can try every one of them okay you crack it and you will figure out whether or not it is this ti if it's not you have to try again so how many message do you need to try you have you have to try or n message because there are n possible keys to the two to the power of 64 okay and then what is the Bob's computation overhead bob's computation overhead is 2 to the power of 64 Bob only need to crack one the bad guy needs to crack all ok so this is where the safety of Marcos paddle come from so let's look at this interesting idea okay so look like we just said what does Bob need to do Bob only needs to choose one message and crack it his calculation computation overhead is 2 to the power 64 what about the attacker the attacker in the worst case needed to correct or end messages and then finally go to the heat of the key so it's n to the power of 64 well so n is what and is the number of keys that Alice can generate so how many keys Alice can generate Alice can generate as many keys as she want Alice can generate to sue the of 36 messages if Alex generally to ^ 36 messages the attackers computation overhead will become 2 ^ 36 times 2 to the power 64 equals 2 2 to the power of 100 that basically means if Bob need one day to crack it you will need a 2 to the power of 36 day to crack it if you bobbin either one minute to crack it you will need a 2 to the power of 36 minute to crack it so your overhead will increase linearly to the number of n that's why we say in the Merkel's puddle Mirko actually treated the communication overhead for computation overhead now the bad guy has to compute all the possible values to crack it and then get the secret from Alice and Bob's point of view we are just required we're just a sending and the receiving a whole lot of messages so if you have a high speed of communication line you can make the life of the bad guy miserable because you can dump a whole lot of message to Bob and the bad guy M will have to compromise every one of them ok this is the Merkel's puddle so it's very interesting in the trade of the communication overhead for computation overhead and now the bad guy has to compromise in the brute-force attack which means try every possible key for every possible message that Alice delivers to Bob which will increase the bad guys computation overhead graphically and make the crack of the secret time very very long so it's very very interesting and if my memory is correct Mirko used the design of the Merkel's puzzle as his project for the semester and somehow the teacher does not like his design and I think gave him a pretty bad score but surprisingly this design stays and make a very interesting case for us to study okay we're going to pretend very shortly about the next two things one is the random number okay so random number is widely widely used to for example we just mentioned many times that you may need to generate the key and if you need to generate the key you need a random number unfortunately most of time when we use especially in the computers we're using pseudo-random numbers which basically means is actually a very very long sequence of the numbers and we just make them look like random and you are actually so the whole procedure is predetermined so you are only choosing different items in a very very long sequence of random of the pseudo-random number so the problem is the number looks like a random number but it's actually pretty determined so if I know which item in the long sequence you choose I will know exactly which number you are using this is very bad because under many conditions when your browser talk to the banks or talk to other webpage security they need some random number to generate the key and this random number is supposed to be real and if it's a fake random number it's a pseudo random number if we could predict which random number you are gonna be use we will be able to figure out the key between you and a bank America you will not be very happy if the bad guy can do that okay and there are real run that random number the real random number are mostly generated in the nature in the great nature for example if you guys have lava lamp you could have matter the time difference between two bubble pop up from the lava lamp and if the time difference is an all the seconds it gives you a bit one if it's even number of seconds between two bubbles it gives you a bit there oh okay surprisingly lava lamp is a very good random number generator or the interval between earthquakes it's also a very good random number unfortunately okay last but not least we're talking about a do encryption we have Alice and Bob and each side as the public and private key pairs so let's say Alice want to send a message to Bob and she want to make sure first only Bob can see it and the second pop can verify that this is from Alice but not from anybody else so what okay Alice - Alice can actually do two things I can sign with private key of Alice and the N inside we will encrypt with public key of Bob and then the message or another format is that I can first assign with my private key Alice and then outside I'm going to use the public key of Bob to open it to encrypt it so you can see these are two possible approaches they're just in different orders they're just in different orders of encryption you can first use public key of Bob to encrypt and add inside or you can first assign and then encrypt which one is better okay this way is better make sure you sign first and then outside you use public key to encrypt why because who can open this who can open this only Bob can open this only the holder of the private key of Bob will be able to open this let's look at this who can open this this is signed by the public by the private key of Alice who can open this envelope whoever owned the public key of Alice so basically under both cases you are putting the message in a double envelope you first have an envelope and outside you have another envelope in this case you cannot open the outside envelope in this case everybody who has the public key of Alice will be able to open the outside envelope and then he or she has to stop at the inside Amy look so in other words this outside envelope does not serve the purpose because everybody could open it so from this side point of view is much better to sign first to sign first so it's much better to sign the message first and then use Bob's public key to encrypt the packet okay so we leads to several reasons okay and last suggest left a suggestion I don't know when the personal private key will take off but if it ever take off the public/private key pair for a single user for a individual user like us don't ever sign a random number that you don't know how it is generated don't ever sign a random number because if you say a random number you may sign a contract that'll sell your kids to the government and you don't really want that to happen okay we will stop here and we will see you in the next week have a good one  
