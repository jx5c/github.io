good afternoon and welcome back to the 16 200 class and in this week we post a several videos related to key distribution and establishment in networks weather and in the following videos we're going to provide a some comment and if you look at a screen this screen Illustrated a video talking about key distribution through the cementery encryption algorithm Temperley first presents a mechanism which includes the pair white key between every pair of notes so you can see in this slice if you look at the screen of the slides you notice that there are four notes and every node has a parent parent key with the other note for example M 1 will have the pair white key with node number 2 number 3 and number 4 so overall if we have a notes that means everybody will have the minus 1 key because we have unknown all together and they excluded this current one there are n minus 1 link outside and since we count every link twice because every edge we have two ends so we actually count every link twice so overall we're going to have n times the minus 1 divided by 2 keys so we have 5 of n square keys so this approach will not be very scalable so that's why in real life very seldomly you see this full coverage of this pair white key because it's almost impossible to actually distribute the secret to the notes we are roughly at at the time of five minutes and the 38 seconds in this video and if you listen to thumper nay he mentions that this very simple key distribution protocol through entrusted a third party actually he mentioned this is a toy protocol and I totally agree with him and here I'm going to say a few words and explain why this protocol is not really a good idea to establish the parity between the notes okay the very first thing if you are running a protocol through a trusted third party and this guy actually needed to generate keys for every possible communication so we're making one assumption or making one assumption the assumption is that this trusted third party will be able to generate unlimited a number of secure keys okay you will say that is that hard I mean just to generate a secure key I mean it's just like hey I'm tossing a coin right if you need a 128-bit key I'm just going to toss the coin for 128 times right I'm just telling you bits are they hats or tails and then we're good enough theoretically you're right the problem is when you toss the coin you are making 2 assumptions the first assumption is that the coin itself is fair which means it has 50% chance of hat and 50% chance of tail and second you are saying that okay the procedure that you toss the coin is fair which means after you toss it it has 50% chance land on the tail and 50% chance land on the Hat so this is not a trivial problem because even with today when we have computer to generate pseudo random numbers because many under many many conditions the keys or generated a based on the pseudo-random number in a computer surprisingly under many condition the numbers generated by the computer are actually not random enough which basically give the bad guys some predictability of the generated keys which will seriously impact the system safety so the Assumption here is that the TVPA and genuine secure Keys is not something very easy to very to verify in real life okay the second problem of this protocol of this toy protocol actually temporary mentioned it later which is if you look at this message and this ticket the only thing they did is that ok I'm going to put the note identity of this communication pallets and ABAB and also the secret we are going to use in this example is kab and we're going to put the three things in the message and incorrect with the key of ka or Kb okay if you look at this message is there any place in this message that we could use to enforce the freshness of the message in other words if I want to talk to Bob yesterday I get a key and if I want to talk to Bob today I get another key how can make sure that this two keys are actually different and it has not been reused okay why it's so important so if you look at this if you look at this message there is absolutely nothing showing when this key was generated and for how long this key will be safe to be used okay which means if Alice have talked to Bob three years ago and the trustee the third party will generate a message to look like this in the three years later the bad we'll replay this message and it will still be valid because it it's it is follow in Falls the suggested format of every detail of this key tabla Sherman Peugeot that's why later in this video they mentioned that this protocol is vulnerable to this replay attack because there's absolutely no freshness guarantee of this message we don't know when was this key generated and we don't know when this key will expire so this key theoretically can last up forever so the bad guy if the bad guy kept a copy of this message he can reuse it five years later which we don't want we don't want okay the third vulnerability of this protocol is a little bit more tricky but let's look at this two messages okay on the top is something that Alice will be able to open so it contained identities of the two note in the key and the bottom this is another message this two message the inside part are exactly the same the name of a and B and then the key so the two packets before encryption they're exactly the same sorry the only difference is the encryption key which basically means imagine this if Alice is a bad guy okay Alice want to figure out the secret key shared the two Bob and the trusted third party and if you want to do that what do you need if alice is a bad guy and I want to figure out the key between Bob and trusty the third party she will need a whole lot of traffic encrypted it by the secret key of KB and here is exactly what Alice will do Alice will go to the trusted third party said oh I want to talk to Bob and the trusted third party said oh great you won't talk to Bob here is the key for you here is the ticket for Bob and then Alice can than the top message and the see this information in clear text and this the bottom one will be the corresponding cipher text encrypted it by Kb okay so she has one message and the corresponding cipher text encrypted by K beef and then Alice after a nanosecond Alice will come to the trusty the third party said Oh trusty a third party I want to talk to Bob again so give me another key and then the trusty the third party will generate another new kab and deliver the message and the ticket to Alice so now if Alice asked something from trusty the third party every milliseconds every microsecond then in every second Alice will get ten to the power six messages pairs one with the ciphertext one with the corresponding clear text and now in a very short period of time Alice will accumulate or collect a whole bunch of traffic they have the clear text and the corresponding ciphertext encrypted by the secret key of Bob and we know that the more traffic that alleys collect the better chance Alice has to compromise the secret key shared between Bob and the trusty the third party and to make the scenario even worse let's look at this protocol Alice said hey trusted third party I want to talk to Bob trusted third party said here you are and Alice said again I won't talk to Bob here so as we mentioned before now Alice will be able to collect an unlimited number of pairs that they have the clear head she has the clear hexed and the corresponding ciphertext that is encrypted by a secret key of Bob and she can collect as many pair as she wants at the same time during the whole procedure Bob does not know anything because Alice just tell the truck trusted third party said I want to key and trusted third party give her a ticket and while another key a ticket and during the whole procedure the the person Bob is totally blocked by this procedure he had no idea that somebody has collect a whole lot of pairs of clear tags in the ciphertext so this is a potential of malicious attack that Alice can conduct last but not least the trustee the third party based in Porto it's really hard to deploy in real life there are two reasons the first reason is that the trusted third party knows too much it becomes a single point of failure it'll be a very hard target of the bad guy because theoretically if you'll compromise ttp you've got everything so there's no way we can have 80 DB running the risk is too high the second problem is that in real life it's almost impossible for you to find such a node to serve as the TDP because no two companies no two agencies or organizations will agree that okay let him run the run this surface and I'm just going to use the surface provided by a certain party because for example let's say we have company a and Company B and they needed to walk together and then almost immediately they will have that argument said okay who will manage the key and if we set up the TTP at a Company B Company a will say why the heck should I trust your capability to generate the key and at the same time why the heck should you trust you that you're not going to eat drop on the traffic that we are generating right so it's almost impossible there's no way we can't get multiple companies agree on where or who will own this TDP and not to mention different countries okay so this is our comment for this sort of video and I hope you get some useful information and I will see you in the next comedy video  
