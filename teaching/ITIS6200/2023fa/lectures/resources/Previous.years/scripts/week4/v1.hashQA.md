good morning everyone and welcome back to 6282 100 and in this week the first video we're gonna do is we're going to answer several questions Lord I figure out that it is not easy some time to you know directly write a very long paragraph or like a very long page to enter the question I think sometime if we record our video and provide some you know explanation is much better ok so we're gonna try most of them are focusing on the hash function and on the symmetric encryption okay so the first question some of the questions are not very clear I have to say so I will try to answer them based on the my understanding okay we are using a device like this so you'll connect this to your computer you can actually write on the board directly and it will you know recorder the screen okay so I just saw via hello okay so let's get started so the first question is about the hashing function okay I believe one question said is it possible that you hash the same message twice and you actually get a different results so if I have a message m and if I hash M could I get two different results if I hash it at different times okay so basically if the hash function is determined if the hash function is determined it could be as I took sha-1 as a 2 etc 3 or whatever function you choose if the ash if the hash function is determined as well as the message then the result will stay the same that basically means oh I have the same hash function the same message I hashed the today I hash it tomorrow I hash it a thousand times every day you will always get the same result that's why this hash function the hatch without can be used to verify the message integrity if you know if I hash it today and I hash it tomorrow the same message and same function and I got different the result then you're going to be in big trouble okay so first the thing first okay second question is also related to the hash let me see which basically the question is said oh okay so I have let's say we have a 128-bit hash without okay let's say we have 128-bit hash it out and of course we understand that since every bid has two well it's 0 or 1 so all over or you will have 2 to the power of 128 different the hatcheries out different hash result and now I say that oh I give you a hash without I give you 128 a bit and I told you this it's a hash without I want you to find a file F such that hash F equals to the value I gave you okay so this is basically it's whether or not you can reverse the hash function and what is the cost that you have to pay okay so we know that it's a one or twenty eight bit hash value and we have two to the 128 possible values okay and let's say I give you a one or two an 8-bit value and I told you this is Henry's out I want you to find a file F such that hash F equals to this value I gave you okay and the question and the question is why how can it possible okay the possible that to find such a file I need to hash more than two to the power of 128 files okay so I give the value and I want you to find a such a file I want you to find a such a file and a sum and in one of the video we cut our common human we said that it's possible that you need to a hash more than two to the power of 128 of files to find a such file of that hash to this specific value so the question is basic low can how can possible you you needed to attach more than two to the 128 files well you have only 128 bits hatcheries out and there are only 2 to the power 128 possible values so I will give you another example and you will understand why it is possible okay you know instead of we use a very complicated example of 128 bits let's look at a dice ok a dice has six faces one two three four five six on the other side okay so I roll the dice I roll the dice and I've I got a three and I said now you roll the dice and you will continue rolling the dice until you got a three as well so my question is if your roll loaded dice six times we have only six phases of the dice can you always guarantee that you will have a three okay let me rephrase the question okay I roll the dice I got a three and I give the type to you and said okay now start the rolling you will keep rolling until you get a three okay my question is can you always guarantee that you will get a three within six times even though these dice has only six phases obviously the answer is not right because the first time you've got one and then you've got a six you got five you got five you got four you get two you got one you got six you got five so this thing can't continue okay this thing can't continue see erratically you will have a very very low chance very very low chance okay that you roll the dice 100 times you roll the dice 100 times you don't get a three you don't get a three okay now let's go back and look at our case I give you a 128-bit value this is the three I'm giving you okay and you started to generate a file and you start to hash it you hash it oh it's not this value I want so it's X the first file you hash its X and then you have Y Z well and then you you hash another file you have X again okay remember X is not the value I want okay so you are going to have some files having to the same value however this value is not something I want is the same thing like here you roll the dice you have two fives you have the two fives okay but this is not the same as I want I want a three so it's the same thing here you can hash more than two to the 128 files okay if you hash more than two to the power of 128 of files I guarantee you you will have at least two files having the same hash value however that value is not the one we want and also even if you hash to ^ 128 file ^ 128 files it's very possible that you cannot cover every possible hash value okay this is the problem okay so now let's go back look at so if you'll recall a good hash function there are like - there are actually like two properties we needed to enforce okay one is I give you a hash result is computationally infeasible for you to find a file to have it to hash it to help to the value another property of a good hash function is it's very difficult it is very difficult to find two files having the same hash result two different files having the same hash without okay this is actually the pigeon and the pigeon hole problem this is a little bit different from the this is a little bit different from the first of written I give you a hash manual this is actually if you recall when we in our earlier video we discuss the star shape and the or connected crock rough okay so let's say this is the hash value this is the hash value and you generate a file one your hash it you compare whether or not the file while you hash it equals to this as well if it's not you generated file to continuously going off so you can see this is the star shape which basically even when you generate and files you compare your hash it you only compared to this hash value so it's a star shape on the contrary this collision resistance of the second that the server requirement of good hash function it's very difficult to find the two different files have anything it's a different case why you generate file1 your hash it and you generate file to your hash it now you compare the hash without of file1 and file2 they're not the same and then what do you do you generate a file three and now you compare file1 file2 rate hash but you also compare file to and file three hash you generate file for you compare file for to file one file to file three can you see the difference for this graph it's a star shape so you are looking for a sub saharan so every file you generate your hash shade you compare to this specific hash value so even if you generate n files you only got an edge okay every edge it's either equal to the pre computed or provided hash value or not this is a different situation when you have n files will have n files every file every file will be compared with all the other and minus one file okay so if you look at this graph let's try another grab another load file F okay so now you have a node every node has n minus 1 edges and of course every edge is counted two times by two ends of the add for example des the edge connected at five five five and five three found three continents one edge and a file five counted as one edge as well so this edge actually counted twice so you have unload every node has n minus 1 edge and every edge is counted sorry it's coming twice so together you have about half of n times n minus 1 edge that's why while you're talking about the collision of the hash function you have this birthday birthday problem which oh how many people do we need to have in the classroom to have two persons having the same birthday okay you don't need a 365 you'll only need the square root okay so be very very careful the difference between the two collision requirement of a hash function why this the the the why the requirement of this having two files having to the same hash result is actually more demanding than this star shape situation  
