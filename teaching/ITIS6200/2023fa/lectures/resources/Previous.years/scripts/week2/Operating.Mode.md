Intro hi welcome to this video on operating modes now in the last lecture you may remember that we talked about symmetric key cryptography and the last part of that lecture we talked about block ciphers Recall... now i want you to recall that a block cipher takes a fixed size piece of data and encrypts it using a fixed size key so if we have aes here as our block cipher then we take a 128 bit chunk of data a 256 bit key and when we put those together we end up with a 128-bit piece of ciphertext now it's important to note that a block cipher can only encrypt blocks of data and in this case the block size for aes is 128 bits so it can only encrypt data in 128-bit blocks not smaller not bigger exactly 128 bits 


Large Messages? well what if i want to encrypt a larger message so what if i have more than one block for example so if i'm using aes with 128 bit block size that would be 16 bytes what if i want to encrypt something like a 30 megabyte video well there's more than one block in a 30 megabyte video in fact there's a whole lot more so what do i need to do in order to make that happen since my block cipher can only encrypt one block at a time Block Cipher Operating Modes in order to solve this problem i mean the fairly straightforward approach and hopefully you're thinking of this is we could just break up the big chunk of data into blocks that are the right size and just encrypt each of those blocks now the way that we encrypt the blocks after we've broken them up impacts security of the underlying ciphertext when we're done there are five traditional ways that we encrypt these this set of blocks of data and we call them operating modes because they're the ways that we use the block cipher in order to encrypt a large chunk of data we're going to cover three of the five traditional ways in this lecture and i just want to note that there are more than even the traditional five there are others as well 

Electronic Code Book (ECB) so the first method is called electronic codebook and this is kind of the obvious method the first thing that everybody comes up with when they think well how can i break it into blocks and encrypt it in electronic code book you break the data into blocks you encrypt each block independently and then you use the same key for every block so let's look at a diagram of this so ECB: Encryption this diagram which i have shamelessly taken from wikipedia because it's good wikipedia has excellent entries on operating modes actually i'll provide you the link later on in this lecture so we we simply take our plain text data and which is up here at the top and we break it into blocks that are the right size for use with my block cipher so if i was using aes for example then each of these blocks would be 128 bits so i break it into these 128 bit blocks and then i just encrypt each block with whatever key i'm going to use for the encryption i get blocks of ciphertext and then i take each of these blocks of ciphertext and i put them all together and that becomes the ciphertext for my encrypted say video file and i send that along now decryption of this is just doing the opposite which is what you would hopefully expect you take the you take the individual cipher text blocks you decrypt them using the key and you get back the original plain text which you then put back together in order to get the original file so ecb is the straightforward simple approach but it has some problems the main issue 

ECB: Problem is that the same plain text blocks produce the same ciphertext blocks when you're using the same key so if you have two blocks in the file that have the exact same plain text they're also going to have the exact same cipher text now this now originally we talked about a simple cipher the substitution cipher that had the same issue whenever you encrypt the same letter if the same letter is encrypted twice in the same message using a substitution cipher each time it becomes the same ciphertext letter and this allowed people to perform frequency analysis attacks against a substitution cipher well people can do the same thing against an ecb cipher it's just you know a different idea because we're dealing with bits and entire pieces of computer files instead of just individual letters but many computer files or other things you might want to encrypt on a computer already have duplicate blocks by default it's just normal that they would have duplicate blocks and we don't want an attacker to be able to tell this by looking at the cipher text you know so we wouldn't want an attacker to be able to analyze an encrypted file and be able to tell you which blocks are the same because that information could help the attacker figure out something about the original unencrypted version so we don't like this idea so to illustrate this so here's an example of a picture of a penguin and if you encrypt that with ecb and then you just display the encrypted data as if it were an image you get this now if you look at that you should pause and say that's kind of disturbing the encrypted image shouldn't look like the original one but this one kind of does now of course it's not as detailed but no it still kind of looks the same you know so you look here and you can kind of see that the white background here became this pattern here and it's consistent throughout wherever the white is and the black part of the body became some consistent pattern or color here and the yellow on the feet became again a consistent pattern or color here so because of the fact that in an image file we have a lot of repeated blocks of data such as color i mean you know every time we see the color white it's going to be represented the same way in the image file when that white is encrypted it becomes the same thing every time over here so we end up with just by looking at the encrypted data as if it were an image you can see what the original image really was and that's a problem with the encryption so 

Cipher Block Chaining (CBC) an improved approach something better than ecb is called cipher block chaining or cbc in cipher block chaining each block is dependent on the previous one and this finished this fixes a lot of the problems with ecb CBC: Encryption so let's look at what i mean by each block is dependent on the previous one let's start with the middle here instead of the beginning so if i have a piece of plain text in cbc what i do is that before i encrypt it i exclusive wore it with the ciphertext of the previous block so i take the ciphertext to the previous block i exclusive or that with the plain text of the current block and then i encrypt that to produce my ciphertext and what this does is this means that my plain text is mixed in with the previous ciphertext so that even if two plain text blocks are identical when they get encrypted with cbc they're mixed in with something else before the encryption so they don't result in identical ciphertext so even if this plain text and this plain text are identical even if they were the same they would result in different cipher texts because what was encrypted was mixed in with the previous ciphertext it wasn't just encrypting the plaintext data so this solves that problem now one thing i want to point out on here is that the very first block of data that you're encrypting needs what's called an initialization vector because it doesn't have a previous ciphertext block let's take a look at that CBC: Initialization Vector (IV) an initialization vector is put in place because the ciphertext of each block is dependent on the previous block and the first block has no previous block it's the first block of data there's nothing that came before it so you can't exclusive or it with the previous ciphertext there is no previous ciphertext so we pick a random value we call it the initialization vector and we use that as if it were the the previous ciphertext block so that's just what the initialization vector is it's just a randomly chosen value it's not even a secret it's just randomly chosen to in order to add that additional bit of mixing into the first block that you encrypt so what does decryption look CBC: Decryption like for cbc well in in decryption it operates kind of like you would expect we're doing the reverse of what the encryption was so in decryption we take the ciphertext that we have we decrypt it but that doesn't result in the original plaintext that results in a value that's the original plaintext exclusive ord with the previous ciphertext because that's what was encrypted before so in order to recover the original plaintext we have to take that value and exclusive or it with the previous ciphertext which we happen to have because we have all the ciphertext and that allows us to get the plain text so we're simply reversing the procedure that we used to encrypt with cbc which now means that we exclusive or with the previous ciphertext after the decryption and again for the first block we have that initial vector and in this case when you're doing decryption the initial vector is not a random value it's the value that was used during the encryption but since it's not a secret that value can be shared freely i can encrypt choose a random initial vector to start with and i can send you my ciphertext and the initial vector i used and it doesn't change the security of the problem as long as the key remains a secret between you and me so the initial vector is not a secret 

CBC: Better than ECB? so cbc obviously has this big improvement over ecb which is that it doesn't have this one-to-one plaintext to ciphertext mapping so remember our picture of the penguin and when we encrypted it with ecb we ended up with this picture that kind of looks still like a penguin but when you encrypt it with cbc we end up with something that just looks like static now i'm not trying to say that representing ciphertext as a picture and it looking random somehow means that it really is but hopefully you can see that this does eliminate that one-to-one plaintext ciphertext mapping problem that's all these images are meant to illustrate 



CBC: Problem but cbc also has its own problems the biggest one is that if i want to change the plain text of one block i have to re-encrypt every following block because it's a chain right the following block is dependent on the ciphertext of the previous block which is dependent on the ciphertext of the block before that which is dependent on the ciphertext of the block before that so we end up with this big chain so if i'm going to change one plaintext block i end up needing to re-encrypt every block that follows it in the file well that's bad if i'm doing something like a large encrypted file system or even a large encrypted file where someone might want to change just a few bytes on the inside that makes the operation really slow because even if they only change one byte inside of the file or on the file system you have to re-encrypt everything that follows and that would be not wise for certain applications but in other cases it doesn't matter if i'm encrypting network packets or something like that it doesn't matter about changing one byte because bytes are not frequently changed in those scenarios but in some scenarios this could be a bad problem


 Counter (CTR) so another type of operating mode and the third one we're going to talk about today is called counter mode now counter mode is an operating mode that uses a block cipher to simulate a stream cipher now you may remember that a stream cipher just generates a pseudo random string of bits and then exclusive ores that with the cipher text sorry with the plain text in counter mode each block is encrypted independently but it involves incrementing nons and we'll look at that in just a second a nonce is just a number that's chosen randomly but but it's not a secret just like the initial vector it's not a secret in fact a nonce an initial vector are effectively identical in terms of what we're doing but we give them a different name just because of how they're used the initial vector is called an initial vector because it's the initial block used during cbc but a nonce is used because that's traditionally the word for a random value used in an encryption operation CTR: Encryption so anyway let's look at our diagram here so in this case we take our random value our knots and we append a counter to it and then we encrypt that random value using our key we just encrypt the value and that produces some sort of bitstream right it produces a set of bits and those bits are effectively random and we take those bits and we exclusive for them with the plain text in order to get the cipher text for the first block we do the same thing for the second block except now we've incremented our counter when we increment the counter that means that we should get on the output of the encryption a new a totally new set of bits ones that are substantially changed compared to the previous ones so even though my plain text is only changing by potentially one bit my cipher text on the output of the encryption changes significantly so i take those bits and i exclusive or them with the plain text and i get more ciphertext so it's important to note here that unlike the other operating modes we looked at in this case the block cipher is not being used to encrypt the plain text the block cipher is being used to generate a stream of bits that's exclusive ored with the plain text that's a very important distinction well in this case decryption then just involves producing the same set of bits and exclusive ring it with the cipher text just like we would do with a stream cipher you encrypt by exclusive oring with the bit stream and you decrypt by exclusive oring with that same bit stream so in this case our goal is to produce the same bit stream as before and that means that when we're using the block cipher we're still using it in encryption mode because we're just trying to produce the same bit stream we did when we had counter mode encryption so with decryption we're still going to use the encryption mode of the block cipher because again we're not encrypting or decrypting the plain text with the block cipher we're just using it to generate that stream of bits so operating modes are one of those topics that the first time you're exposed to them they're they're difficult to think about and reason about but if you spend more time reading and thinking about them then they kind of become second nature and they become more obvious for you and easier to understand so what i encourage you to do is to go spend more time with them by reading the wikipedia entry on block cipher modes of operation it's a really really really good entry apparently cryptographers love wikipedia and spend a lot of time on there making it strong so the wikipedia entry for these is very good so i would say go to wikipedia look for block cipher mode of operation and you can find an excellent page that describes the five general modes and a few more but gives their pluses and minuses and give you more information about them and i'll add just as a side note if you're ever building something and you need an operating mode chances are really high that cbc is what you want to use the other two modes are useful for specific types of scenarios ecb encounter but cbc's is in general useful for most scenarios that people operate under Summing Up so let's summarize when using block ciphers to encrypt data larger than one block you need to pick an operating mode and your choice of operating mode impacts security performance etc so you have to be able to understand how they work and to think about and reason about them so hopefully this lecture gives you a good introduction to that thanks  