in this segment we're going to look at our first key exchange protocol without a trusted third party so the settings are we have our friend Alice and Bob as usual and these friends have never met before but somehow they want to generate a shared key so what they're going to do is they're going to send messages to one another back and forth and this time there is no trusted third party that they can communicate with and at the end of this protocol somehow they should have a shared key that they both know so there's a secret key K that they both know but an eavesdropper who listens in on this traffic has absolutely no idea what this secret key K is now for now we're just going to worry about attacker is that only eavesdrop on the conversation in other words we don't allow any tampering with traffic all we allow is just eavesdropping and yet the eavesdropper should have no idea what the secret key K is and so we're going to look at a number of key exchange protocols in these settings namely when the attacker is only ease dropping on the conversation but cannot change traffic and we're going to see three protocols that achieve this this goal and the first question though for this segment is can this be done only using symmetric cryptos they can this only be done using block ciphers or hash functions or any of the tools that we've seen in the last four weeks and so very surprisingly the answer is yes in fact we can do key exchange just using block ciphers or hash functions without a trusted third party but unfortunately the resulting protocols are very inefficient and are actually never used in practice nevertheless these are very simple protocols and so I want to show you how they work and then we'll move on to the more efficient protocols that will discuss this week in the next so the simple protocol I want to show you is what's called a Merkel puzzles protocol this protocol was invented by ralphs protocol back in 1974 when he was just an undergraduate interestingly he invented this protocol as part of a seminar that he took but apparently the professor didn't quite understand the significance of the contribution and as a result ralph merkle actually graduated and then moved to Stanford where he became Marty Hellman student and they've done a lot of good things in public key cryptography since then so let me show you how Merkel puzzles work the main tool for this protocol is what's called a puzzle and let me explain what I mean by a puzzle well a puzzle is a problem that's difficult to solve but can be solved with some effort in other words if you really put your mind to it you can solve it and so let me give you an example so suppose we have a symmetric cipher that uses keys that 128 bits long so just think of AES for example and suppose what I do is I choose an aes key such that the first 96 bits are all 0 and only the remaining 32 bits are nonzero and just chosen at random ok so only 32 bits of this of this 128-bit key are random the rest are all 0 and now what I do is I encrypt a fixed plain text for example simply the plain text message using this 128-bit key that happens to be mostly 0 the result is what I would call a puzzle and the reason I call it a puzzle is because it's actually not that hard to find the secret key p simply by trying all 22 the 32 possibilities remember these are the first 96 bits are all 0 so there really only two to the 32 possible keys to try and for each for each key will try to decrypt this puzzle and see if we get the plain text message and if so we know that we've recovered the right the right solution p so within 2 to the 32 work we can actually solve this puzzle namely we can find p just given puzzle p so the way this is going to work as as follows alice is going to start by generating a large number of puzzles in particular she's going to generate two to the 32 different puzzles now each of these puzzles the way she generates it is as follows what you'll do is you'll choose a 32 bit random puzzle p I ok to see does this for i equals 1 to 22 32 and then she's going to choose two more values X I and K I that happen to be 128 bits each now what you'll do is you'll use the puzzle p I as an aes secret key ok so she'll create 128-bit key where 96 of the bits are set to 0 and only the 32 lou significant bits happen to be random ok so this is a key that only has 32 bits of entropy if you like and there are only two to the 32 such he's now the Playtex that she'll encrypt using this key is this message that I wrote over here basically it starts off with the word puzzle that puzzle is a 10 / the identifier X I which happens to be 128 bits and to that we concatenate the value ki which also happens to be 128 bits okay so she does this for all I to to the 32 puzzles and as a result she gets to to the 32 different puzzles she then goes ahead and sends these two to the 32 puzzles to Bob now what does Bob do while Bob receives this flood of 2 to the 32 different puzzles he's just going to choose one of them he doesn't even have to remember any of them he just randomly let's most of them go by and he happens to choose one of them let's say he chose puzzle number J then he spends time to to the 32 and solves this puzzle well what does it mean to solve this puzzle he's going to try all possible values of pie he's going to decrypt the puzzle that he chose and he's going to check whether the first part of the plaintext starts with a word puzzle and if it does he knows that he's correctly solved that puzzle and then he basically obtains the data embedded in the puzzle namely XJ and KJ okay so remember XJ is this value that I'd it identifies the puzzle and KJ is going to be a secret that they use so now he solved the puzzle he knows that he solved the puzzle correctly and he obtained this XJ and KJ what he'll do is he'll send XJ back to Alice just the value x JK j he keeps for himself and keeps it the secrets and then alex is simply going to look up in her database of puzzles she's going to look up puzzle number XJ and then she knows that Bob chose I the key KJ and now they have this shared key so KJ is going to be the shared key that they used to communicate securely with one another so in a diagram the way this protocol works is as follows Alice starts off by sending two to the 32 puzzles to Bob so we can generalize this let's say that she sends n puzzles to Bob and let's say that each puzzle takes work proportional to n to solve Bob solves one of these puzzles and then he sends back XJ to Alice ok so so far each one of them spent work n and then Alice basically looks up puzzle XJ and recovers the key the corresponds to this puzzle and there's a result both of them now have shared key that they confused to communicate with one another okay so let's look at the work that they did so what the work that Alice did is he had to prepare and puzzles while preparing the puzzle takes constant time I she had to prepare end puzzles so her work is roughly order n Bob chose one puzzle and solved it so his work is also proportional to ord rents a linear in n so now let's see what the East drop has to do well the poor eavesdropper sees these end puzzles go by and then he sees this XJ come back and he doesn't really know which puzzle Bob actually solved all he sees is his random value inside of the puzzle and so to break this protocol the eavesdropper would actually have to solve all puzzles until he finds the right puzzle that has the value x j unit and then he will recover k Jake so my question to you is what is the attackers work how much work did the eavesdropper have to spend to break this protocol so the answer is of course order N squared you know quadratic time and n he had to solve and puzzles each puzzle takes time and to solve and as a result he had to spend time order N squared in our example we said that there were two to the 32 puzzles and each one took two to the 32 time to solve so overall the attackers work is roughly two to the 64 steps so you can see the problem with this protocol first of all the participants Alice and Bob had to do quite a bit of work themselves if you think about it Alice basically had to send two to the 32 puzzles to Bob that's many many gigabytes that she had to send to Bob like 16 or 32 gigabytes depending on how big each puzzle is Bob had to spend time to to the 32 to solve one of these puzzles so that will take a few seconds to but then all the security they got is that the attacker can break this protocol in time to to the 64 so soon to 64 is still not considered particularly secure as a result the attacker really if you really wanted to break this protocol he could so to make the security the participants would have to increase the parameter N and they would have to send say two to the 64 puzzles to one another and then spend time to to the 64 to solve each puzzle and then the attackers worked would be 2 to the 128 which is considered secure but having the participants spend time to to the 64 or to set up a secure session is a little bit too much to ask each of these participants so this is why this protocol is not particularly used in practice but nevertheless there's a really nice idea here in that the participants had to spend linear time where the attacker had to spend quadratic time so there's a quadratic gap between the amount of work that the participants have to do versus what the attacker had to do to break the protocol so a natural question is can we actually do better than a quadratic gap just using symmetric ciphers in other words just using tools that we developed in the first four weeks of the class and the answer really is that this is unknown we don't know whether quadratic gap is the best that we can do you might even try to think about this a bit how would you use AES or shop 256 to do key exchange then achieves better than a quadratic app but I can tell you that we believe that quadratic is the best we can do and there are even some negative results along those lines so roughly speaking there is a result that says that in fact if we treat the block cipher or the hash function that we use as a black box Oracle in other words all the participants can do is just query the block cipher or query the hash function at certain points and receive the the results if that's all they're allowed to do in other words they're not allowed to actually use the implementation of the cipher or the hash function then in fact there is a result that says that if the participants only query the block cipher endpoints there will always be an attack that runs in time and squared so again this suggests that if all you do is use the block cipher as a black box that you query then whatever key exchange you come up with there will always be a quadratic attack on this key exchange and in fact at the end of this module I point to this paper it's a fairly recent paper from 2009 just shows that quadratic is the best we can do so if you want to read more about this impossibility result you know go ahead and take a look at this paper it's actually a very readable paper and you should be able to understand it and so the question is what to do next so now we're kind of stuck we said that with block ciphers we really can't do better than a quadratic gap and so what do we do so this was kind of the starting point of public key cryptography and the realization is that we need more than just generic block ciphers and generic hash functions we actually need function is that have very very special properties and to build these functions we actually have to rely on some algebra so in the next few segments we're going to look at some algebraic instructions and then we'll see how to use those for key exchange and for many other things in public key cryptography  
