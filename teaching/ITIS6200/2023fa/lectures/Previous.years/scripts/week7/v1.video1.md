n this module i want to show you another approach to key exchange based on the concept of public key encryption so again just to remind you of the settings we have our friends Alice and Bob as usual and their goal is to exchange a secret key K they used to opera get to see the messages they send to one another but even though he shouldn't learn anything about the key K that they exchanged in as usual in this module we're only going to be looking at eavesdropping security that is we don't allow the attacker to tamper with data or to mount any other form of active attack so just to remind you earlier in this module we saw an inefficient mechanism based on genetic block ciphers in the previous segment we saw the diffie-hellman key exchange mechanism which has an exponential gap between the work that the participants have to do versus the work that the attacker has to do and in fact this de Hamal protocol is used all over the web very frequently in this segment that I want to show you a different approach based on public key encryption so what is public key encryption so just as in the case of symmetric encryption there's an encryption algorithm and a decryption algorithm however here the new corruption algorithm is given one key which we're going to call a public key let's call this the public key that belongs to Bob and the decryption algorithm is given a different key we'll call it a secret key that also belongs to Bob so these two these two keys are sometimes called a key pair one half of the pair is the public key and the other half of the pair is the secret key now the way you encrypt this as usual a message would come in the encryption algorithm will generate a ciphertext that is the encryption of this message using the given public key and then when the ciphertext is given to the decryption algorithm the decryption algorithm basically outputs that corresponding a message so as I said PK is called a public key and SK is called the secret key so more precisely what is public key encryption well public key encryption is actually made up of three algorithms GE and D algorithm G is what's called a key generation algorithm when you run algorithm G it will output two keys the public key and the secret key the encryption algorithm basically given the public key and message will outputs the corresponding ciphertext in the decryption algorithm given the secret key in the ciphertext well output message or will output bottom if an error occurred and as usual we have the usual consistency properties that say that for any public key and secret key that could have been output by the key generation algorithm if we encrypt a message using the public key and then decrypt using the secret key we should get the original message back now what does it mean for a public key system to be secure well we use the same concept of semantic security that we used before except the games now are a little bit different so let me explain how we define semantic security for a public key system so here the Challenger is going to run the key generation algorithm to generate a public key and a secret key pair and he's going to give the public key to the adversary the challenger keeps the secret key to himself what the adversary will do is he will output to equal length messages m0 and m1 as before and then the Challenger will give him the encryption of m0 or m1 as usual we define to experiment experiment 0 and experiment 1 in experiment zero the adversary is given the encryption of m0 in experiment 1 the atmosphere is given the encryption of m1 and then the adversary's goal is to guess which encryption he was given was he given the encryption of m0 or was he given the encryption of m1 and we refer to his guests as the output of experiment 0 or experiment 1 one thing i want to emphasize is that in the case of public key encryption there's no need to give the attacker the ability to mount a chosen plaintext attack why is that well in the case of a symmetric key system the attacker had to request the encryption of messages of his choice in the case of a public key system the attacker has the public key and therefore he came by himself encrypt for himself any message that he wants he doesn't need the challenges helped to create encryptions of messages of his choice and as a result in the public key settings a chosen plaintiffs attack is in erin's there's no reason to give the attack or extra power to mount a chosen plaintext attack and that's why we never discussed chosen plaintext queries in the context of defining semantic security for public key systems now that we define the game we're going to say that a public key system gee d is semantically secure if basically the attacker cannot distinguish experiment 0 from experiment 1 in other words the adversaries probability of outputting one in experiment zero is about the same as this probability of outputting one in experiment one so again the attacker can tell whether he was given the encryption of m0 or the encryption of m1 now that we understand what public key encryption is let's see how to use it to establish a shared secret so here are our friends Alice and Bob Alice will start off by generating a random public key secret key pair for herself using the key generation algorithm and then she's gonna send to Bob of the public key PK and she also says hey this message is from Alice what Bob will do is he will generate a random 128-bit value X and he will send back to Alice saying hey this message is from Bob and he'll send back the encryption of X under Alice's public key Alice will receive the ciphertext she'll decrypt it using her secret key and that will give her the value X and now this value X can be used basically as a shared secret between the two of them I want to emphasize that this protocol is very different from the DC hublin protocol that we signed the last segment in the sense that here the parties have to take turns in the sense that Bob cannot send his message until he receives the message from Alice in other words Bob cannot encrypt X to Alice's public key until he receives the public key from Alice in a defilement protocol however the two parties could send their messages at arbitrary times and there was no ordering and forced on those messages as a result we had this nice application of DC Hellman where everybody could post their messages to Facebook for example and then just by looking at Facebook profiles any pair would already have a shared key without any need for additional communication here this is not quite true even if everybody posts their public use to Facebook there would still be a need to send this message before I shared key can be established so now that we understand the protocol the first question we need to ask is why is this protocol secure and as usual we're only going to look at eavesdropping security so in this protocol the attacker gets to see the public key and the encryption of X the public key and what he wants to get is basically this value X now we know that the system the public key system that we use is semantically secure what that means is that the attacker cannot distinguish the encryption of X from the encryption of something random in other words just given encryption of X the attacker can't tell whether the plaintext is X or just some random junk that was chosen from m and because of that that basically says that just by looking at messages in this protocol the value of x is indistinguishable in the attackers view from a random element in em and as a result X can be used as a session key between the two parties it's just a random value which the attacker cannot actually guess other than by trying all possible values in em and I should say that showing that these two distributions are indistinguishable follows directly from semantic security and in fact it's a simple exercise to show that if the attacker could distinguish this distribution from that distribution then the attacker could also break semantic security and as usual even though this protocol is secure against eavesdropping it's completely insecure against a man-in-the-middle attack so let's see a simple man in the middle attack well so here we have Alice generating her public hue secret key pair at the same time the man in the middle is also going to generate his own public key secret key pair and now when Alice sends her public key over to Bob the man in the middle will intercept that and instead he'll say yeah this is a message from Alice but Alice's public key really is PK prime so now Bob receives this message he thinks he got a message from Alice what he'll send back is well he's going to choose his random X and he'll send back the encryption of X under PK prime the man in the middle is going to intercept this message and he's going to replace it with something else so his goal is to make sure that the key exchange succeeds in other words Alice stinks that she got a message from Bob and yet the man in the middle should know exactly what the exchange secret is so what should the man in the middle send out to Alice in this case so here let's call the ciphertext see what the man in the middle will do is he will decrypt the ciphertext see you his own secret key and that will reveal X to the man in the middle and then he's going to go ahead and encrypt X under Alice's public key send the value back to Alice Alice will obtain this X and as far as she's concerned so you just did a key exchange with Bob we're both of them learned the value X but the problem of course is that the man in the middle also knows the value X so this protocol becomes completely insecure once the man in the middle can tamper with messages from Alice to Bob and from Bob Dallas so again we have to do something to this protocol to make it secure and we're going to see how to do that actually in two weeks after we introduce digital signatures so now that I've shown you the public key encryption implies key exchange secure against eavesdropping the next question is how do we construct public key encryption systems and it turns out that these constructions generally rely on number theory and some algebra and just like the diffie-hellman protocol relied on some algebra and so before we go into these protocols o in more detail what I'd like to do is kind of take a quick detour in the next module we're going to look at the relevant number theoretic background we'll just do one module on this and then we'll come back and talk about these public key constructions and more constructions for key exchange so this is the end of this module and as further reading I just wanted to point to this paper that shows that if in fact all we do is rely on symmetric ciphers and hash functions then Merkel puzzles are optimal for key exchange and in fact we cannot achieve more than a quadratic gap as long as we treat that primitives we're given as a black box so basically this shows of the quadratic gap is the best possible and also I wanted to point to another paper that kind of summarizes some of these key exchange mechanisms that we talked about key exchange using public key cryptography and key exchange using diffie-hellman you can take a look at this paper and it kind of will give you a look ahead into what's coming and how to make these key exchange protocols secure against man in the middle and not just secure against eavesdropping okay so that's the end of this module and the next module we'll take a brief detour and do a kind of a brief overview of algebra number theory  
