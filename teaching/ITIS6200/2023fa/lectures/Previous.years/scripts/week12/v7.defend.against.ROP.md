good morning everyone and welcome back to 62 180 200 and in this video we are going to continue to discuss to return horan to the programming attack so if you recall in the previous video we introduced how that the ROP attack is conducted so basically the bad guy will go through the above overflow attack to manipulate that stack and when they manipulate the stack they needed to put specific values into certain area into the stack to control the return function of the stack so basically through the buffer overflow the bad guy will will overwrite the original value in the stack remember the stack here is growing down okay let's say this is return address for this return address three return address two and return address one and this is the bottom of the current stack so we are executing about here and this have all the data so the bad guy will overwrite this section and put a corresponding return address and the data in the whole stack so that it will control how the execution of the program will be conducted it in this way they can leave the malicious segment of code and hopefully eventually they will get the malicious logic okay so now let's take a quick look and about the defense of the mechanism of the return oriented programming so when we look at the return oriented programming we find out that there are several things lead to the abnormal so if we want to detect attack we need to find out what is abnormal make sense okay there are several things that is really abnormal the first thing is we have returned but we do not have called what does that mean if we are executing a real program okay so in the function three let's see my bad okay so if we are doing really a normal execution function three we'll call function tool and and then function tool will call function one solo and so forth so every time you will first have a call and then you'll have a return rather you'll need to enter the function and then you'll return what is this return oriented programming this is my function 1 this is the enter this is the you know when you call function 1 it will enter here and here is the return what are the bad guys doing the bad guy only need a small segment of the code right above the return ok so where will the function jump in it will jump in here so the malicious code will not enter the function through the normal entrance but it's true in the middle of the function ok so there's no call but there is a return ok so what is the defense mechanism what is the defense mechanism that people have designed they will maintain a global wearable okay they will maintain a global variable the global wear bulb will start from zero okay it will start from zero every time there is a function call I will increase the value by one so basically it goes one layer deeper into the stack because you're starting from here when there's nothing going on okay whenever you are doing a function call I need to put a frame a frame into the stack it goes down so every time we have a function call I will +1 for the variable every time I have a return I will minus one okay so let us post here for five seconds you think about it so if this is a normal program if you this is a normal program will you ever see the global value here we set up smaller than zero I will recommend you post a video for 5 seconds enter this question and continue to watch okay I hope you have a thought about it if this is a normal function you should never ever see this global value smaller than zero why you first a call and then return okay so basically when you actually kill to the program it will go start from zero and then to one that basically means you call a function and we didn't function why you co another guide so the global value will become to become 3 and then back to 2 because the function 3 exit and then it calls another function it enter 3 again so on and so forth but it will never ever appear in the case that it's smaller than 0 however what about the ROP what about the return or until II the program what about the return or until program let's take a quick look what about ROP you do not have call but you have a lot of returns ok so wherever this global variable you'll start so start this through the buffer overflow you enter the system right to enter the system and at that time the global variable will have a value it could be 10 it could be 20 so on and so forth and then what will the malicious lodging or malicious program - it will leave a whole lot of returns ok now we have a problem every time you call the return so that you execute one segment of code this global variable will be minus 1 and you go another return into a minus 1 another returning your code management and sooner or later you're going to see suddenly the minus 1 appear for the global wearable okay in other words either started to become smaller than theorem that basically means hey there's no call but there are a lot of returns there are so many returns that it actually back up from the whole stack that is a very very weird situation and this will actually lead to an alarm said hey there is abnormal in our stack function okay so what is the good of this approach is very simple it's very simple to implement you only need to maintain a global variable and from the system point of view that's probably just a register okay we will keep the register there every time you do a function call we +1 every time you return with minus one it's relatively simple okay and actually we would call this effective okay what is the bad thing the bad thing is you are going to experience some delay before you can actually detect this abnormal what doesn't mean okay so let's say if your current value of the global variable is 20 what does I mean that basically means the bad guy will be able to weave 20 levels of segments of code before it is detected it okay the 20 levels of segments of code how much malicious logic it can be executed it depends okay if you can find a segment that actually killed 100 instructions then 20 of them will be pretty good for the bad guy on the contrary if you can only execute a one instruction before the return then 20 level that patient means 20 instructions okay we know that in modern computers 20 instructions were provided very limited incapability okay if that is case a better guy will not have a lot of manipulation space so from this point of view it will cause some delay that basically means from the attack is conducted it until the time that it is it is detected it there might be some damage down to your system okay this is this is one thing that people have designed to defend against the ROP attack okay what is the second approach this is also very interesting okay we have been you guys have been taking the course for quite some time and we know that encryption is a very effective mechanism in security enforcement okay so we have described in a class clearly that the encryption or cryptography is not the solution for all security problems but occasionally and well I will not say occasionally but very frequently the encryption can actually save a lot of the trouble okay what does this mean here what do we do encryption okay when we do a function call when we do a function call the system will encrypt the return address will encrypt the return address okay if when we do the function call we do an encryption of the return address and when we return of the function what do we need to do we need to decrypt okay of course the key is stored somewhere in the hardware like a register and there will be some segments of code every time it is executed you will call either encryption or recruitment function decryption function what does I mean if you look at its tag here when we do the function call instead of directly storing the return address of our for here we actually store encryption of the key with the key the return address encryption with the key of our three the encryption of the with the key r2 and encryption with the key or what okay so now when you are executing the return function all everything will be automatically they will be automatically done by the hardware the hardware will extract this encryption result apply the decryption function to whatever it is and then it will recover the address and then jump back okay okay so now let's see what will happen to the ROP attack okay so let's say you are the bad guy and of course through buffer overflow you can grab the control of the stack and now you need to write something into the stack okay you understand that you need to write the encryption with the key of your target address into this place however there are two problems first you will know the encryption function you're the bad guy you know the encryption function you will know the target address the only thing you don't know is a key is a key remember the key is stored in the hardware you know register when the system put up probably every time when the system could have the key will be dynamically generated and every time when you start the system the key is actually different okay so from this point of view at this time you're the bad guy you are only doing buffer overflow you have not grabbed control the whole system in other words you do not have the privilege to access this register actually I heavily doubt whether or not the Intel or whoever is the OS or hardware manufacturer will ever provide you an interface to directly access the key you cannot read the key because it is controlled by the hardware and under no circumstance you actually need to accept a key okay so you're the bad guy you are trying to just to use the buffer overflow to control how the execution in the program okay so you do not have the privilege to access the hardware register that basically means you don't know the key of course you're gonna say hey I'm the bad guy I can I don't know the key I will just you know take a wild guess of the key let's say it's P prime you can take a wild guess of the key and then you just encrypted the address with the K Prime that you'll take a while to gas and write it into here so let's see what happens is instead of a write with the with the correct encryption result you are just writing something well basically you're just writing something random into this place okay so you generate a random key K Prime in the god-forbid hope that K prime is the same as the K but of course I could say that almost a 100% sure it will be different so you'll write it into this segment and then it started to run and when it heat the return when he didn't return the computer will automatically extract this key and apply the decryption function in Twitter so what will happen you are going to the hardware to the decryption with the K but inside is the encryption with the K Prime with an address so what will happen some random address will showed up okay so this will not be the address you want it to be but some other value okay you would say hey I'm the attacker I'm still Isis to succeed right because this will be some random address and you're going to jump to that address there's a good chance it will lead it to the crash of the system you're gonna see blue screen I still succeed I'm a bad guy you're totally right you're totally right under this case there is a good chance you are going to jump to some in the middle of nowhere address and leave it to the system crash and it will be the blue screen okay now let's look at it is this the goal of the bad guy I mean you leave it to a blue screen and what would I do if my machine was compromised and needed to a blue screen what will happen I will have to reboot my machine right I will reboot my machine some of my data may get lost the problem is what do you get as an attacker do you grab the control of my computer no you don't the only thing is you cause me some trouble but you do not get anything out of it that is not purely the case of modern cyber attack the cyber attack try to get into the system hide it into the system and try to steal your password steal your bank account all that need steals it needs to stay in your machine without being noticed if you have a blue screen that's a pretty bad situation because the bad guy got noticed but he does not get any knowledge of them so this is the second approach that people have suggested to defend against ROP attack so what is the good the good is is all implemented in the hardware I'm sorry automatically okay you can manager the key you can do the encryption you can do the decryption function and you can do the encryption and the decryption function all through the hardware it will be transparent to the users okay what is the bad thing the bad thing is now we need to slow things down why because traditionally you just put the address into the stack and now what we need to do you need to not only store the address you need to the encryption and a decryption function okay it could be a symmetric encryption or symmetric decryption function however it still takes time remember this function call happens all the time in our system it continuously doing again and again and again okay so that basically means we are slowing down a operation that runs many many many times in our system okay so it will actually cause the performance penalty in the operating system so of course this we just here we just introduced to Mack Needham to defend against ROP attack if you're interested I believe there has been already a PhD thesis I forget from which university but I have well I have read that before there has been a PhD sis's a whole 200 page or so document and writing about a different ways of defending against ROP attack and the to approach we introduced take different passes one is trying to trace the execution procedure and the to map every function call and every return together okay if you have a return you're sure they have a call okay the second approach we introduced directly touch the return function okay we want to make sure that you cannot jump to the correct space through the encryption I hope this video provide you some useful information about the defense against the ROP attack again just like the the video that we played a right before our our sessions is a cat and a mouse situation we are always chasing after some bad guy and we always try to figure out what's going on and the bad guy always try to you know based on our defense mechanism to come up with something new to defeat us so it's it's really an interesting game that's why we believe that information security is a very promising direction to pursue okay I hope you like this video thank you so much and I will see you in the next session bye  
