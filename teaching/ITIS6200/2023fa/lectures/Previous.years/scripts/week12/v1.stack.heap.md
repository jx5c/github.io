this is erica cooksy and welcome to my presentation on the stack versus the heap or memory management in c and c plus so by the end of this presentation you should be able to answer the following questions first and foremost what's the difference between stack memory and heat memory where memory leaks caused are they caused on the stack or on the heap and how can we prevent them in our code if we try to fill a buffer past its capacity why don't we just allocate extra memory on the end so if we have a 10 byte buffer and we try to stuff 11 or more bytes in it why don't we just grow the buffer to accommodate those extra bytes we probably have plenty of memory why does the buffer overflow cause the whole program to crash again we probably have plenty of memory why does it matter if we just allocate a couple extra bytes on the end of an array why can't we allocate an array with a non-constant such as a user supplied index so here's an example snippet of code that will not compile we have the user enter an array size uh we save that to an integer called our size and we try to declare an array like so using our size to give the number of items that need to be in the array this won't compile why not why can't the compiler figure out something that's simple so we'll start our presentation with some basic definitions first off the heap the heap is a large pool of operating system memory and it's used in dynamic memory allocation in c plus we use the new keyword if we're using old style c we use the mallet keyword and those allocate memory on the heap the stack and first off keep in mind that even though the stack does resemble the data structure stack we're not talking about just the data structure we're talking about the stack as it relates to memory management so each process gets its own stack that's what we're talking about here the processes stack and we're only going to talk about single threaded processes today just for the sake of simplicity so each process gets its own stack just like the data structure a pro processes stack is last in first out so like the stack of books here the last book that you put on top is the first one that you're going to take off and it's a contiguous block of memory within the processes address space so let's see the stack consists of stack frames so each stack frame contains the parameters to a function its local variables and the data necessary to recover the previous stack frame so when a function is called a frame for that function is pushed onto the stack when the function is done executing we pop the stack frame and return to the caller so when we call a function we grow the stack by pushing the stack frame for that function on on top when we're done with it the stack shrinks by popping it off we return to the caller which is now on top of the stack so stack contains very high performance memory and there's usually a fixed limit of stack memory that you could allocate for a particular program so here's an example that shows two different ways of allocating an array one goes on the stack and one goes on the heap for the stack we just declare an array like this with the constant size in the index and with the heap we actually use the new keyword and it this in this case is a static value but we could actually use a dynamic one like one that we received from the user like we saw in the previous code example and we can allocate dynamically on the heap we have plenty of space in the heap and we don't need to know at compile time how much we're going to use so we're going to start with a short review of basic chip architecture and assembly language calls this is going to be a very very short explanation just to go over what we need to to understand these concepts so what is assembly we think of assembly as machine instructions c is a higher level language which gets translated into assembly by the compiler the key point here is that the assembly language tells the computer exactly what to do and exactly how to do it so in cc or c plus plus we'll just say something a little more high level in general like allocate memory or perform addition and assembly we're going to drill down to the specifics of put this byte from this address and memory into that register or jump to this location in memory these do the exact same things we'll go over the assembly code in a minute we see that the assembly is a little more complicated assembly language is non-portable and it's specific to that particular platform in chipset so if you have the exact same c code uh it'll be compiled into assembly language that's different for say an intel 64-bit cpu it'll be different for a motorola 68 cpu even with the exact same c code but it's easier to program and see as you could tell the code is easier to read and it's more portable just as an aside very high level languages that run on a virtual machine such as java get translated into proprietary sort of assembly in the case of java it'd be java byte code and that can run on that particular virtual machine let's talk about registers we're going to define them as extremely high performance memory that's located directly on the chip or the cpu general purpose registers we use these conventions for for example in intel and other cpus eax ebx ecx and edx we use these for performing optima operations on data so because these are very high speed registers being directly on the chip we won't directly work with data while it's in memory we'll usually take the data out of memory put it into the registers perform our operations there and then put it back into memory because these are very very high speed we also have special purpose registers which have a designated purpose for each one so the examples that we're going to talk about with relation to the stack are esp which is the stack pointer that always points to the top of the stack and it's manipulated by a push and pop instructions with ebp which is the base pointer it's a a little easier to think of it as the frame pointer and with the frame pointer local variables and parameters within a stack frame are referenced by their offset to ebp an evp is fixed for that particular frame whereas the stack pointer can move as items are pushed and on and popped off of the stack that's why we use ebp within that particular stack frame and esi and edr are respectively the source instruction register and the destination instruction registers and we use these to keep track when we're calling functions and returning from them so we know where to go where to come back so here's a very basic review of assembly language calls and it's very very abridged we're not going to cover i o interrupts or anything just cover what we're what we need to know for this so assembly language uh calls can be of the form opcode and then destination source so for example move eax 1 moves the value 1 into the eax register they can also be perform opcode and then operand so for example a jump instruction is like the assembly equivalent of a go to if we do jump to this hex address it just jumps to that address in memory and starts executing the code there in this case the hex address is uh hexadecimal deadbeef we also have stack related mnemonics such as push pop call and ret ret or return push writes the value from the register to the stack so push grows the stack by taking the values from the red register that we're pushing and putting it on the stack pop writes the value to the register from the stack removing it from the stack so push grows it pop shrinks it call we do it in the form of call and then function it's very similar to a jump except that it returns to the caller when done and call is generally accompanied by pushing values from the functions frame onto the stack and re returns from the function that was called and this is generally accompanied by popping the functions frame off of the stack returning to the caller so enough powerpoint let's see some code in action so now we're actually going to look at some code so what's nice about the visual studio ide is that we can actually view the disassembly of the c code in line with the c code and we can also look at the contents of the registers look at the contents of the memory all kinds of fun stuff so here we've defined a very simple function called my function takes x as a parameter and returns uh one plus x so let's step into this here we can view the disassembly [Music] when we view the disassembly we can see that here's our call to the function step into that and here's everything that happens when we call a function this is everything that we talked about before calling the function involves a lot of pushes returning from the function involves a lot of pops so we enter the function we copy the contents of the stack pointer into the frame pointer or base pointer evp we push the base pointer onto the stack in addition to the source instruction the destination instruction all that gets pushed on the stack local variables are allocated by subtracting their size from the from the stack pointer so after we do all that we can finally execute the body of the function pop all of our values off the stack for this stack frame and then return so let's see so here we've already done everything and then we can return from our function so let's look at something that's a little bit more interesting we have a function here called set buffer now what set buffer does is we allocate a local buffer on the stack that has 10 bytes of memory it's 10 characters one character is one byte and it receives as a parameter um another character buffer and a number of characters so it allocates on the stack a 10 byte buffer and then we copy the input buffer into that local one and then just return so we build our project here we see that we're creating a new 10 byte buffer in the main just full of a bunch of capital b's and then calling set buffer with that and the number 10. so here we step in viewer disassembly [Music] here's all our pushes that we talked about create the the new buffer everything's fine we call mem copy to to copy the 10 bytes from the input into the the 10 bytes in the local buffer and everything is fine so here we can see the addresses of all of our pointers are not all of our pointers all of our registers so local buff is this address when we view it in memory i guess we'll have to actually type it in let's see our buffer we perform the mem copy it puts all the beads in there uh the hexadecimal ascii value of b is 42 so that's what we have and we can see that it's on the stack it's right next to the frame pointer base pointer it's next to edi it's next to everything that that's in that stack frame it's part of why it's very high performance it's very compact we call the function we can return everything goes just fine now what if we do things a little bit differently and instead of passing 10 bytes into the 10 byte buffer we put 255 bytes into that 10 byte buffer now what do we think happens so we're going to debug into this step into it view our disassembly so now look local buff is still very close to ebp edi all the other pointers that that relate to our current stack frame because we think that all we're going to need in this local buff here all we're going to need is 10 bytes so we've allocated basically just enough space for that so now here's our call to mem copy here's local buff let's put the value in the memory window here step over make all our calls that we need to do to call mem copy so now that buffer is all full of 42s but what happens to everything else that's within that frame here's ebp it used to hold a hexadecimal address that we would need for knowing all the offsets from the frame pointer that's all full 42s our destination instruction register is all full 42s we have no idea where anything is because all of these important registers are now all full 42s and if we continue trying to execute we get a stat corruption no surprise there [Music] so now say if instead of allocating all this on the stack we allocate it on the heap we use the new operator that we talked about before and we use numchars which comes into the function as our parameter to dynamically allocate it here we go step into it so here we've instantiated it on the heap so you can see our ebp or edi everything else we see that the address of heat buff is way somewhere else out in the pool of operating system memory we have plenty of space it's nowhere near the other pointers on the stack frame we don't have to worry about overwriting anything and we can dynamically allocate it at runtime we perform the mem copy now one thing that you may have noticed is that as soon as that stack frame is popped that memory that we had in local buff automatically gets deallocated when we're allocating heat memory we're responsible for cleaning up after ourselves and that's why every time we call the new keyword we also have to call the delete keyword when we're done with it to deallocate that memory otherwise we just continue allocating memory and we never give it up and this program runs just fine so now let's go back to our original question that we talked about we talked about what's the difference between stack memory and heat memory so where memory leaks caused on the stack or on the heap clearly they're caused on the heap because we can allocate first off lots more memory and we were responsible for our own memory deallocation in order to prevent them from happening we're going to have to de-allocate our own memory every time we allocate it as soon as we're done with it if we try to fill a buffer past its capacity why don't we just allocate extra memory on the end well we're talking about a buffer on the stack here we can't allocate extra memory on the end because we haven't accounted for needing it there and we have a bunch of other important information in that memory location such as the the frame pointer the destination address the source address everything else why does the buffer overflow cause the whole program to crash well when we call rhett we try to go back to the caller that the address of the caller has been overwritten by some garbage data that we overflowed from past our buffer why can't we allocate an array with the user supplied index because we need to know at compile time how much space we need for that buffer on the stack so when do you use which stack is extremely high performance and it's automatically deallocated by the program so we use a stack when we can however the heap gives us access to a large much larger pool of memory and it's dynamic we can dynamically allocate it uh so even if we don't know this size of our buffers or classes at compile time we don't have to worry about that until the program actually runs that was my presentation i hope you found it informative  
