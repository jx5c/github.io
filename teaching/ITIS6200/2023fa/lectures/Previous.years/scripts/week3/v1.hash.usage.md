https://www.youtube.com/watch?v=2Cg2So2js5k

hello welcome to this lecture on hashing in this lecture we're going to talk about hashing and what it is and some of the uses that it has within computer science and in security now you may remember from previous lectures that hat in hashing we take an arbitrary message and we compute a fixed length hash now sometimes we call that hash a message message digest so you may see a hash or message digest used if you're reading about this hashing is used outside of security as well in fact the principles behind hashing are used in a lot of different areas of computer science and they're used in a lot of different systems so out of all the things that we talked about in this course hashing is the one that you may see the most outside of security applications but so while any security hash function can be used for a lot of other purposes not every other type of hash function can be used for security so we're going to talk about today are specifically called cryptographic hash functions and that just means that they were designed with some extra mathematical properties in place that make them safe to use for security and cryptographic purposes let's look at an example so we have some arbitrary amount of data it doesn't matter how much it is it could be 1 bit it could be 1 million bits it could be a terabyte it doesn't matter any amount of data and we feed that into our hash function in this case I've just picked one called sha-1 that's just an actual hash function and what we get out and with the example of sha-1 is a fixed length 160-bit hash so it doesn't matter how much data you put in you always get out 160 bits so if I put in 10 bits here I get 160 out if it's 100 bits I get 160 out it's a thousand bits I get 160 out so it doesn't matter how many bits I put in I always get 160 bits but this output will be very different depending on the input so as a sample of how hashing is used in Sample in Python say like a programming language I just picked Python because it's usually pretty easy to understand in this case I just you know created an instance of a hash function method hash function object I added some text to it and then I just said create a hi jet create a digest and print it out and traditionally when we print out pecks or hashes we print them out in hexadecimal so let's look at some Properties of a Secure Hash Function properties of a secure hash function so if we're going to use a hash function for security it has to have some special properties the first is called preimage resistance or where it needs to be one way and what that means is that it's infeasible to determine the original message if you're given a hash so it's infeasible to determine m from a hash of M so if I hash something and I give you the hash you're not able to take that hash and go backwards to find a message that has that hash now the next property is called second preimage resistance and in second preimage resistance we say that given M one its infeasible to find M 2 such that the hash of M 1 equals the hash of M 2 so if I give you a specific message you're not able to find another message that has the same hash as the one that I gave you and the third property of a secure hash function is called collision resistance and this says that you can't find any M 1 M 2 such that the hash of M 1 equals the hash of M 2 so at this point a lot of people stop and they say well wait what's the difference between 2 and 3 in both cases you're trying to find two messages that have the same hash and you're right in both cases we're trying to find two messages that have the same hash but in second preimage resistance you're given a specific message m 1 and told to find another message with that hash in collision resistance you're told to find any two messages that have the same hash so from an attackers perspective if an attacker is trying to break these properties it's easier for an attacker to break collision resistance because collision resistance can be broken with any two messages where a second preimage resistance you have to find another message with the same hash to a specifically given so it's the difference between a specifically given message you have to match and finding any two messages with hashes that match so if I were going to Breaking Pre-Image break preimage resistance what would I need to do remember the premium preimage resistance says they give in a hash find a message with that hash well I mean the brute force approach brute force meaning I just try it I just keep trying and testing and seeing if I get it in a brute force approach I would just pick a message hash it and compare it to the hash that I have if they match then yay I found a message with that hash if they don't match then I pick another message hash it and compare it to the hash that I have oh just keep picking random messages and hashing them until I find one that matches the message that I chose how long would this take well in the best case my first guess would be correct I would be like the luckiest person in the universe and I would just pick a random message and hash it and it would happen to hash to the exact same thing as the hash that I'm trying to match I would be incredibly lucky in fact the chances of that happening are so small it's not even worth talking about but that would be the best case in the worst case I would be the unluckiest person in the universe and I would keep picking random messages and random messages and hashing them and I would find every other possible hash first and then lastly I would find the one that I'm looking for so in my best case I get it in one in my worst case that's for every other possible hash and so if I'm dealing with say a 128-bit hash just pick that number for fun so if I'm dealing with a 128-bit hash then there are 2 to the 128th possible different hashes and if I find all of the others first well then I would find my answer at 2 to the 128th minus 1 in the average case I would hit somewhere in the middle no not someone that I in the average case I would hit right at the middle I would find it halfway through so that would just be the worst case more or less divided by 2 so I would get about 2 to the 127 which at first glance you pause and you say wait wait if you're dividing this big number by 2 that should make it substantially smaller and it does but remember we're dealing with powers of 2 so dividing 2 to the 128th by 2 only gets me to the 127 which is still a really big number so how big of a number is 2 to the 127 it's about 1.7 times 10 to the 38th so that's like a 1 with 38 zeros after it that's an extremely large number if you were to write a really fast computer program to try this approach which is pick a message hash it check it pick a message hash to check it it would take you an incredibly large amount of time before you would finally break - so this is really not feasible for someone to do it would take way way way too long so Breaking 2nd Pre-Image how about if I need to break second preimage resistance and if you remember second preimage resistance says that given m 1 I need to find an M 2 such that the hash of M 1 equals the hash of M 2 so in preimage resistance I was given a hash in second preimage resistance I'm given the message well if you're going to apply the brute force approach you would use the exact same approach we did for preimage resistance actually I would simply hash the message and then I would perform the brute-force attack against that hash to find another message with that hash so the attack would be basically the same in the brute force approach now in collision Breaking Collision Resistance resistance remembering collision resistance we're trying to find any two messages with the same hash when we're trying to break collision resistance things get a lot more complicated so in order to understand how you could write collision resistance on a hash you need to learn a part of probability called the birthday paradox to explain Birthday Collision it I'm gonna use an analogy I called the birthday collision so the birthday collision is assuming that all birthdays are equally likely how many people do I need to get together in a room before two of them have the same birthday and if two people do have the same birthday in a room I'm going to call that a birthday collision so that's the problem how many people do I need to get in a room before any two of them have the same birthday now this problem is distinct from a related but different problem which is how many people's do I need to get in a room before one of them has my birthday and I hope you can see the difference there in that in the latter case I'm trying to match someone else to a specific birthday mine but in this case I'm just trying to have any two people with the same birthday so those are two different problems even though they sound disturbingly similar but remember here any two people with the same birthday well the rule of thumb and we get this from what's called the birthday paradox if you do the statistics out the rule of thumb is that if turret if there are n different possibilities of something then you need square root of n randomly chosen items in order to have a 50% chance of a collision so what does that mean for the birthday collision idea well if there are 365 different possibilities of birthdays well the square root of 365 is about 23 so the answer to our birthday collision question is that we would need about 23 random people before we have a 50% chance that two of them have the same birthday and that number is actually fairly low most people would think it would be higher you know just intuitively you think how many people do I need before they have the same birthday hundreds but really it's only about 23 in fact if you get 23 23 people together in a room you have about a 50% chance of a birthday collision now for birthdays this doesn't necessarily hold because the truth is that birthdays are not equally likely to happen on every day of the year some months are more likely to have birthdays than others etc etc but hopefully it's a good analogy to help you understand the birthday paradox so this is the birthday paradox if there are n different possibilities then square root of n is all I need to have before there's a 50% chance that two of them are the same so how does this apply to hashing will recall that Birthday Paradox and Hashing collision-resistant says that I can't find any M 1 or M 2 such that the hash of M 1 equals the hash of M 2 well if I were to just start generating hashes and storing them you know so I pick a random message hash it pick a random message hash it and I keep track of all of the hashes how many hashes do I need to collect before I get a collision it's almost the exact same question is the birthday collision question it's just we're dealing with hashes instead of birthdays well for a 128-bit hash there are two to the 128 possible hashes so if I've so if I apply the birthday paradox well then the square root of 2 to the 128th is 2 to the 64 so that's how many hashes I would need and that's still a big number but this means that the strength is similar to breaking preimage resistance for a 64-bit hash function so I can break collision resistance significantly easier than preimage resistance for example because the birthday paradox brings down this 2 to the 128th power and really ends up reducing it to something as small as a 2 to the 64 power Examples of Real Hash okay so let's talk about some examples of real hash functions so the first one I want to talk about is called md5 an md5 produces a 128-bit hash but md5 has some mathematical weaknesses that smart cryptographer people have an out have analyzed it and they found that they can actually find collisions so break collision resistance in only storing about two to the twenty-one hashes which is significantly less than the tutu's 64 that it would be in theory so this that's bit that's because they've analyzed the algorithm and found mathematical weaknesses in it sha-1 is another real hash function and it's a 160-bit hash and as cryptographers have analyzed it they found that collisions can be found in about two to the sixty-one hashes so the theoretical wave the theoretical limit for hash for finding collisions would be about two to the eighty but they can find it to 261 sha-2 which was an effete version of sha-1 is actually four different hash functions with different size outputs you know so Shah 224 is you know a hash function versus a 224 bit output shot 256 produces a 256 bit output and so on the sha-2 series of hash functions there are very very minor attacks but overall these are still considered good we don't know of any tax against collision resistance that significantly reduce the computation time so that's good these are more commonly what people will be using today if they want a good secure hash function and then there's an even newer hash function called sha-3 you might notice the trend in the naming called sha-3 that was just chosen now as a new standard for NIST which is the National Institute of Standards in the United States and it's new enough that there's no known attacks people have been analyzing it but they've only been analyzing it for a few years and so at this point it's considered very good but you want to wait until people spent enough time with it but it is probably very good so in practice today when designing new systems most people are going to either use one of the shot to functions or the sha-3 function because both md5 and sha-1 have potential attacks that reduce its collision resistance now finding a hash collision in 2 to the 61 is not not incredibly feasible that could be difficult but finding one in 2 to the 21 that's very feasible you could write a computer program to do that in a reasonable amount of time so Applications of Hash let's talk about some applications of hash functions so some some things that people use hash functions for is to detect errors and file transfers so for example BitTorrent uses hashes to detect if there was an error in some of the blocks of data that it retrieves from peers another use of hash functions is something called a message authentication code which is a way that two people who share a key can can basically use a hash with a key in order to guarantee the integrity of something another good usage of hash functions is in password storage when an application is storing the passwords of users specifically server-side applications let's talk about each of these okay so Application: File Transmission for the file trance I dia of guaranteeing that the file hasn't been corrupted hash functions are used in a really simple way what you do is you the distributor the person who's going to you're going to download the file from takes the file however big it is and they run it through a hash function you get out this hash value here and they just they just put it on the website sometimes you'll see this when you download files you'll see here's the file and here's its hash you may have wondered well what's the hash for the hash is for verifying that when you download the file it wasn't corrupted because if the user downloads the file and the hash and the files received correctly well then when you when the user hashes that file using the same hashing algorithm that the distributor did the hashes will match you know so that the hash that the user downloaded from the distributor and the hash that they generated from the file will match because they were generated from the same data so same data into the hash function gets the same data out but if there was any error during the download even one bit if even one bit is different then after I hash it I'll get a completely different looking hash so if one bit changes here the output will be substantially different just like block ciphers you may remember that in a block cipher if one bit of the plaintext changes the cipher text changes significantly in a way that's indistinguishable from random the same is true fresh functions so if there's any bit errors at all in the download then the hashes won't match and you'll be able to detect so it's a nice way to verify that file that a file hasn't been inadvertently corrupted during a download so another application of hash Application: MAC functions it's called a message authentication code and this is basically hashing with a key the goal is to create a hash that can only be created or verified by someone who has the key so if you and I share a key and I want to send you a message and I want you to be able to to verify that the message came from me and hasn't been changed by anyone in the middle then you could just then we could use this we could use a message authentication code - hash the file with the key share the hash with each other and then we could detect if anyone altered it there are different techniques the simple thing is I could just say well I'm going to hash the message and on the end of the message I'm just going to add the key right so whenever the secret key is just gets added to the end and then I hash that whole chunk and I get a hash but this is bad because of how some hash functions are designed just putting the key on the end it's not always the best approach I could put the key at the beginning this is better because hash function designs don't necessarily cause this to be a problem but some research has been done to very to say that there are other better ways to do it I could put it on both sides I could put the key at the beginning in the end which would be better still but the best way to do it and the way that's provably good is this actually so we hash first with the key at the beginning of the message and then we hash again with the key at the beginning of that hash so we do the hash twice with the key at the beginning both times and this is provably good and provably meaning that someone has verified mathematically with formal proofs that this is sufficient for guaranteeing the integrity of the message so this is the best way to do it provably you know someone has verified that but it's also slower because you're doing twice now another application that Application: Password people use for hash functions is password storage so if you design an application that stores passwords usually like a web application or some site of servers some sort of server you don't want to store them in plain text and the reason is that if anyone breaks into your server that's that's hosting this application and they steal your database or your password file well then they have all the passwords of all of your users and that's a horrible thing because the users may reuse passwords to other systems or the attacker then just has all the passwords for your system it's just not a good situation so instead you should be storing hashes of the passwords instead of the passwords themselves and I want to make a note that if you're really going to do this you don't just store hashes you do something specific with a hash that adds some security so if you ever need to do this just go look up password-based key derivation functions or pbkdf2 type that into Google you'll find all sorts of useful reading if you really do need to store passwords but the core of that technology is just using hashing so as an example here's say a password file that a system might use and what we would have is say okay well here's the users account name it's just our email address and here is a hash of their password so instead of storing their actual password you just store a hash and that's useful and helpful and then if an attacker breaks in they don't get the password they get the hash and if the attacker wants to get the original password he has to brute-force it he has to break a pre-image resistance by randomly not randomly but by hashing potential passwords in comparing to this hash so it significantly increases the work an attacker has to do to get the passwords even if he manages to steal the password file so that right there is using hashing to help with password storage Summing Up so let's summarize what we talked about hash functions take an arbitrary message and they compute a fixed length hash with it and they have many applications in computer science even outside of security so don't be surprised if you see hashing in use in other areas of computing but they're based on the same basic technology that we just talked about here thanks  
